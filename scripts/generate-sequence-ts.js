/// the generator generates src/generated/sequence.*.generated.ts
/// You can regenerate with 

/* eslint-disable eslint-comments/no-unlimited-disable */
/* eslint-disable */

const {writeFileSync} = require('fs')
const {join} = require('path')

writeFileSync(join(__dirname, "..", "src", "generated", "sequence.async.ts"),
  generateCode(true))

writeFileSync(join(__dirname, "..", "src", "generated", "sequence.normal.ts"),
  generateCode(false))

function generateCode(generateAsync) {
  const Async = generateAsync ? 'Async' : ''
  const async = generateAsync ? 'async' : ''
  const asyncIterator = generateAsync ? 'asyncIterator' : 'iterator'
  const awaits = generateAsync ? 'await ' : ''
  const Awaitable = generateAsync ? (t => `Awaitable<${t}>`) : (t => t)
  const Promise = generateAsync ? (t => `Promise<${t}>`) : (t => t)
  const ifNormal = generateAsync ? (() => '') : (t => t)
  const ifAsync = generateAsync ? (t => t) : (() => '')

  return `// generated by generate-sequence-ts.js
// do not edit manually
// noinspection JSUnusedGlobalSymbols
${ifAsync(`
import {Awaitable} from '../types'`)}${ifNormal(`
import {AsyncSequence} from '../utils/sequence'`)}

export class ${Async}Sequence<T> {
  private readonly iterator: ${Async}Iterator<T>

  constructor(iterator: ${Async}Iterator<T>) {
    this.iterator = iterator
  }

  [Symbol.${asyncIterator}](): ${Async}Iterator<T> {
    return this.iterator
  }

  map<R>(f: (it: T) => ${Awaitable("R")}): ${Async}Sequence<R> {
    return new ${Async}Sequence({
      next: ${async} () => {
        const res = ${awaits}this.iterator.next()
        return res.done ? res : yields(${awaits}f(res.value))
      },
    })
  }

  mapNotNull<R>(f: (it: T) => ${Awaitable("R | null | " +
    "undefined")}): ${Async}Sequence<NonNullable<R>> {
    return this.map(f).filter((it): it is NonNullable<R> => it != null)
  }

  // typescript doesn't allow Awaitable<it is R> so use it is R for async
  filter<R extends T>(f: (it: T) => it is R): ${Async}Sequence<R>
  filter(f: (it: T) => ${Awaitable("boolean")}): ${Async}Sequence<T>
  filter(f: (it: T) => ${Awaitable("boolean")}): ${Async}Sequence<T> {
    return new ${Async}Sequence<T>({
      next: ${async} () => {
        for (;;) {
          const res = ${awaits}this.iterator.next()
          if (res.done)
            return res
          if (${awaits}f(res.value))
            return res
        }
      },
    })
  }

  zipWithNext(lastNull: true): ${Async}Sequence<[T, T | null]>
  zipWithNext(lastNull: false): ${Async}Sequence<[T, T]>
  zipWithNext(): ${Async}Sequence<[T, T]>
  zipWithNext(lastNull = false): ${Async}Sequence<readonly [T, T | null]> {
    let prev: T|null|undefined = undefined
    return new ${Async}Sequence({
      next: ${async} () => {
        if (prev === null)
          return ended()
        if (prev === undefined) {
          const r = ${awaits}this.iterator.next()
          if (r.done) {
            prev = null
            return r
          } else {
            prev = r.value
          }
        }
        const r = ${awaits}this.iterator.next()
        let res: IteratorResult<readonly [T, T | null]>
        if (r.done) {
          if (lastNull)
            res = yields([prev, null] as const)
          else
            res = ended()
          prev = null
        } else {
          res = yields([prev, r.value] as const)
          prev = r.value
        }
        return res
      },
    })
  }

  // typescript doesn't allow Awaitable<it is R> so use it is R for async
  takeWhile<R extends T>(f: (it: T) => it is R): ${Async}Sequence<R>
  takeWhile(f: (it: T) => ${Awaitable("boolean")}): ${Async}Sequence<T>
  takeWhile(f: (it: T) => ${Awaitable("boolean")}): ${Async}Sequence<T> {
    let iterator: ${Async}Iterator<T> | undefined = this.iterator
    return new ${Async}Sequence({
      next: ${async} () => {
        if (!iterator)
          return ended()
        const res = ${awaits}iterator.next()
        if (res.done || !${awaits}f(res.value)) {
          iterator = undefined
          return ended()
        }
        return res
      },
    })
  }

  ${async} asArray(): ${Promise("T[]")} {
    const res: T[] = []
    for ${awaits}(const elem of this) {
      res.push(elem)
    }
    return res
  }

  ${async} sum(): ${Promise("T extends number ? number : number | never")} {
    let res: number = 0
    for ${awaits}(const elem of this) {
      if (typeof elem != 'number')
        throw new Error(\`some element is not a number: \${elem}\`)
      else 
        res += elem
    }
    return res
  }${ifNormal(`

  asAsync(): AsyncSequence<T> {
    return new AsyncSequence<T>({next: async () => this.iterator.next()})
  }`)}
}

function yields<T>(value: T): IteratorYieldResult<T> {
  return { done: false, value }
}

function ended(): IteratorReturnResult<undefined> {
  return { done: true, value: undefined }
}
`
}
